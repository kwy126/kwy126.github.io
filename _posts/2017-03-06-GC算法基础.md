垃圾回收器会关注以下两个方面：

* 找出所有存活的对象

* 清理所有的其他（废弃或无用）的对象



下面介绍如何找出存活对象

## 标记可达对象

![对象图](photos/2017-03-06-GC算法基础/Java-GC-mark-and-sweep.png)
上图表示某个应用的<font color="red">对象图</font>，每个圈表示一个对象，其中，标记为蓝色的圈为存活对象，而标记为灰色的圈为废弃对象，即垃圾对象，图中的GC Roots对象（根对象），表示某些特殊的对象，包括：

* 当前执行方法中的所有的本地变量及入参

* 活跃线程

* 已加载类的静态变量

* JNI引用



**Notes**

* 开始进行标记前，需要先暂停应用线程，否则如果对象图一直再变化的话是无法真正去遍历它的。暂停应用以便JVM可以尽情的收拾家务这种情况被称之为安全点（Safe Point），这会触发一次Stop The World（STW）。触发安全点的原因有很多，，但是最常见的是就是垃圾回收

* 暂停时间的长短并不取决于堆对象的多少也不是堆的大小，而是存活对象的多少。因此，调高堆的大小并不会影响到标记阶段的时间长短



## 删除无用对象

完成标记阶段之后，GC进入下一个阶段，删除不可达对象

不同的GC算法在删除无用对象上的做法会有所不同，不过大致可以分为三类：清除(Sweeping),整理/压缩（Compacting）以及拷贝(Copying)。下面详细介绍这三种方法。



#### 清除

标记-清除算法是最简单的，值需要忽略这些对象就可以了。

但是这个方法需要使用一个空闲列表来记录所有的空闲区域以及大小。对空闲列表的管理增加了分配对象的工作量。这种方法还有一个缺陷就是<font color="red">碎片问题</font>，即虽然空闲区域的大小总体来说是足够的，但是没有一个单一区域能够满足这次分配所需要的大小，因此本次分配还是会失败（在Java中就是一次OutOfMemoryError）


![清除图](photos/2017-03-06-GC算法基础/GC-sweep.png)

#### 整理

标记-整理算法修复了标记-清除算法的短板（碎片为题）：它将所有标记为存活对象移动到内存区域的开始位置。

这种方法的缺点就是GC暂停时间会增长，因为你需要将所有的对象拷贝到一个新的地方，还得更新他们的引用地址。

![整理图](photos/2017-03-06-GC算法基础/GC-mark-sweep-compact.png)



### 复制

标记-复制算法和标记-整理算法非常类似，他们都会将所有存活对象重新进行分配。却别在于重新分配的目标地址不同，复制算法的为了存活对象分配了另外的内存区域作为他们的新家。

标记-复制算法的优点在于标记阶段和复制阶段可以同时进行。

它的缺点是需要额外的空间来容纳所有的存活对象

![复制图](photos/2017-03-06-GC算法基础/GC-mark-and-copy-in-java.png)


## 参考连接

1. [有浮](http://it.deepinmind.com/gc/2016/07/09/garbage-collection-algorithms.html)
